// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 3beb4722ca
// Version Date: 2019年10月24日 星期四 23时47分48秒 UTC

package svc

// This file provides server-side bindings for the gRPC transport.
// It utilizes the transport/grpc.Server.

import (
	"context"
	"net/http"

	"google.golang.org/grpc/metadata"

	grpctransport "github.com/go-kit/kit/transport/grpc"

	// This Service
	pb "github.com/metaverse/truss/_example"
)

// MakeGRPCServer makes a set of endpoints available as a gRPC SkAppServiceServer.
func MakeGRPCServer(endpoints Endpoints) pb.SkAppServiceServer {
	serverOptions := []grpctransport.ServerOption{
		grpctransport.ServerBefore(metadataToContext),
	}
	return &grpcServer{
		// skappservice

		seckill: grpctransport.NewServer(
			endpoints.SeckillEndpoint,
			DecodeGRPCSeckillRequest,
			EncodeGRPCSeckillResponse,
			serverOptions...,
		),
		secinfo: grpctransport.NewServer(
			endpoints.SecInfoEndpoint,
			DecodeGRPCSecInfoRequest,
			EncodeGRPCSecInfoResponse,
			serverOptions...,
		),
		secinfolist: grpctransport.NewServer(
			endpoints.SecInfoListEndpoint,
			DecodeGRPCSecInfoListRequest,
			EncodeGRPCSecInfoListResponse,
			serverOptions...,
		),
	}
}

// grpcServer implements the SkAppServiceServer interface
type grpcServer struct {
	seckill     grpctransport.Handler
	secinfo     grpctransport.Handler
	secinfolist grpctransport.Handler
}

// Methods for grpcServer to implement SkAppServiceServer interface

func (s *grpcServer) Seckill(ctx context.Context, req *pb.SecRequest) (*pb.SecResponse, error) {
	_, rep, err := s.seckill.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*pb.SecResponse), nil
}

func (s *grpcServer) SecInfo(ctx context.Context, req *pb.SecInfoRequest) (*pb.SecInfoResponse, error) {
	_, rep, err := s.secinfo.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*pb.SecInfoResponse), nil
}

func (s *grpcServer) SecInfoList(ctx context.Context, req *pb.SecInfoListRequest) (*pb.SecInfoListResponse, error) {
	_, rep, err := s.secinfolist.ServeGRPC(ctx, req)
	if err != nil {
		return nil, err
	}
	return rep.(*pb.SecInfoListResponse), nil
}

// Server Decode

// DecodeGRPCSeckillRequest is a transport/grpc.DecodeRequestFunc that converts a
// gRPC seckill request to a user-domain seckill request. Primarily useful in a server.
func DecodeGRPCSeckillRequest(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*pb.SecRequest)
	return req, nil
}

// DecodeGRPCSecInfoRequest is a transport/grpc.DecodeRequestFunc that converts a
// gRPC secinfo request to a user-domain secinfo request. Primarily useful in a server.
func DecodeGRPCSecInfoRequest(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*pb.SecInfoRequest)
	return req, nil
}

// DecodeGRPCSecInfoListRequest is a transport/grpc.DecodeRequestFunc that converts a
// gRPC secinfolist request to a user-domain secinfolist request. Primarily useful in a server.
func DecodeGRPCSecInfoListRequest(_ context.Context, grpcReq interface{}) (interface{}, error) {
	req := grpcReq.(*pb.SecInfoListRequest)
	return req, nil
}

// Server Encode

// EncodeGRPCSeckillResponse is a transport/grpc.EncodeResponseFunc that converts a
// user-domain seckill response to a gRPC seckill reply. Primarily useful in a server.
func EncodeGRPCSeckillResponse(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*pb.SecResponse)
	return resp, nil
}

// EncodeGRPCSecInfoResponse is a transport/grpc.EncodeResponseFunc that converts a
// user-domain secinfo response to a gRPC secinfo reply. Primarily useful in a server.
func EncodeGRPCSecInfoResponse(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*pb.SecInfoResponse)
	return resp, nil
}

// EncodeGRPCSecInfoListResponse is a transport/grpc.EncodeResponseFunc that converts a
// user-domain secinfolist response to a gRPC secinfolist reply. Primarily useful in a server.
func EncodeGRPCSecInfoListResponse(_ context.Context, response interface{}) (interface{}, error) {
	resp := response.(*pb.SecInfoListResponse)
	return resp, nil
}

// Helpers

func metadataToContext(ctx context.Context, md metadata.MD) context.Context {
	for k, v := range md {
		if v != nil {
			// The key is added both in metadata format (k) which is all lower
			// and the http.CanonicalHeaderKey of the key so that it can be
			// accessed in either format
			ctx = context.WithValue(ctx, k, v[0])
			ctx = context.WithValue(ctx, http.CanonicalHeaderKey(k), v[0])
		}
	}

	return ctx
}
